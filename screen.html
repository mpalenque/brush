<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wallpaper Screen - Multi-Display</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #f0f0f0;
            min-height: 100vh;
        }

        .wallpaper-container {
            width: 100%;
            min-height: 100vh;
            position: relative;
            overflow: hidden;
        }

        .pattern-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .screen-info {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
            font-family: monospace;
            display: none;
        }

        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #17a2b8;
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
            display: none;
        }
    </style>
</head>
<body>
    <div class="wallpaper-container" id="wallpaperContainer">
        <canvas class="pattern-canvas" id="patternCanvas"></canvas>
        
        <div class="screen-info" id="screenInfo">
            <div><strong>Screen ID:</strong> <span id="screenId">0</span></div>
            <div><strong>Offset X:</strong> <span id="currentOffset">0px</span></div>
            <div><em>Presiona 'i' para ocultar/mostrar esta información</em></div>
        </div>
    </div>

    <div class="connection-status" id="connectionStatus">
        🔌 Conectando...
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const patternCanvas = document.getElementById('patternCanvas');
        const ctx = patternCanvas.getContext('2d');

        // Obtener Screen ID de la URL
        const pathParts = window.location.pathname.split('/');
        const screenId = parseInt(pathParts[pathParts.length - 1]);

        // Elementos de UI
        const elements = {
            screenInfo: document.getElementById('screenInfo'),
            screenId: document.getElementById('screenId'),
            currentOffset: document.getElementById('currentOffset'),
            connectionStatus: document.getElementById('connectionStatus')
        };

        // Estado del wallpaper
        let wallpaperState = {
            general: {},
            screen: {},
            wallpaper: { isActive: false }
        };

    let img = new Image();
    let imgLoaded = false;
    // Perfume image (extra decorative layer) - load independently
    let perfumeImg = new Image();
    let perfumeLoaded = false;

        // Mostrar Screen ID
        elements.screenId.textContent = screenId;

        // Configuración de canvas
        function setupCanvas() {
            const dpr = window.devicePixelRatio || 1;
            patternCanvas.width = window.innerWidth * dpr;
            patternCanvas.height = window.innerHeight * dpr;
            patternCanvas.style.width = '100%';
            patternCanvas.style.height = '100%';
        }

        // Generar patrón estático (sin animación)
        function generateStaticPattern() {
            if (!imgLoaded) return;
            
            const config = wallpaperState.general;
            const screenConfig = wallpaperState.screen;
            
            const repX = parseInt(config.repetitionX || 10);
            const repY = parseInt(config.repetitionY || 8);
            const size = parseInt(config.patternSize || 245);
            const dpr = window.devicePixelRatio || 1;
            const width = window.innerWidth * dpr;
            const height = window.innerHeight * dpr;
            
            // Offset específico de esta pantalla
            const offsetXVal = (screenConfig.offsetX || 0) * dpr;
            const rotationVal = parseInt(config.rotation || 0);

            const spacingX = width / repX;
            const spacingY = height / repY;
            
            const imgAspect = img.width / img.height;
            let baseWidth = size * dpr;
            let baseHeight = size * dpr;
            if (imgAspect > 1) baseHeight = baseWidth / imgAspect;
            else baseWidth = baseHeight * imgAspect;

            // Limpiar canvas
            ctx.save();
            ctx.clearRect(0, 0, width, height);
            
            // Color de fondo
            ctx.fillStyle = config.backgroundColor || '#ffffff';
            ctx.fillRect(0, 0, width, height);

            // Solo dibujar si el wallpaper está activo
            if (wallpaperState.wallpaper?.isActive) {
                // Efectos globales
                ctx.globalCompositeOperation = config.blendMode || 'multiply';

                // Transformaciones globales
                ctx.translate(width / 2, height / 2);
                const zoomVal = parseFloat(config.zoom || 1.2);
                ctx.scale(zoomVal, zoomVal);
                if (config.patternType === 'diamond') {
                    ctx.rotate(Math.PI / 4);
                }
                ctx.translate(-width / 2, -height / 2);

                let counter = 0;

                for (let j = 0; j < repY; j++) {
                    for (let i = 0; i < repX; i++) {
                        let x, y, instRotation = rotationVal, scaleMod = 1;

                        // Calcular posición según el tipo de patrón
                        switch (config.patternType) {
                            case 'grid':
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'brick':
                                x = i * spacingX + (j % 2 === 1 ? spacingX * 0.5 : 0);
                                y = j * spacingY;
                                break;
                            case 'hexagon':
                                x = i * spacingX + (j % 2 === 1 ? spacingX * 0.5 : 0);
                                y = j * spacingY * 0.866;
                                break;
                            case 'diamond':
                                x = i * spacingX + (j % 2 === 1 ? spacingX * 0.5 : 0);
                                y = j * spacingY * 0.8;
                                break;
                            case 'mirror-horizontal':
                                if (i % 2 !== 0) instRotation += 180;
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'mirror-vertical':
                                if (j % 2 !== 0) instRotation += 180;
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'mirror-both':
                                if (i % 2 !== 0) instRotation += 180;
                                if (j % 2 !== 0) instRotation += 180;
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'rotate-90':
                                instRotation += (counter % 4) * 90;
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'rotate-180':
                                if (counter % 2 !== 0) instRotation += 180;
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'rotate-mixed':
                                instRotation += [0, 90, 270, 180][counter % 4];
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'scale-varied':
                                scaleMod = [1, 0.6, 1.4, 0.8][counter % 4];
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'alternating-scale':
                                const scaleDiff = parseFloat(config.scaleDifference || 1.5);
                                scaleMod = (counter % 2 === 0) ? 1 : scaleDiff;
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'organic-complex':
                                // Patrón orgánico complejo con posiciones y rotaciones variadas
                                const patterns = [
                                    { offsetX: 0, offsetY: 0, rotation: 0, scale: 1 },
                                    { offsetX: spacingX * 0.3, offsetY: spacingY * 0.2, rotation: 180, scale: 0.8 },
                                    { offsetX: -spacingX * 0.1, offsetY: spacingY * 0.4, rotation: 90, scale: 1.2 },
                                    { offsetX: spacingX * 0.2, offsetY: -spacingY * 0.1, rotation: 270, scale: 0.9 },
                                    { offsetX: -spacingX * 0.2, offsetY: -spacingY * 0.3, rotation: 45, scale: 1.1 },
                                    { offsetX: spacingX * 0.4, offsetY: spacingY * 0.1, rotation: 135, scale: 0.7 }
                                ];
                                const patternIndex = counter % patterns.length;
                                const pattern = patterns[patternIndex];
                                
                                // Agregar variación adicional basada en la posición de la fila/columna
                                const rowVariation = (j % 3) * spacingX * 0.15;
                                const colVariation = (i % 2) * spacingY * 0.1;
                                
                                x = i * spacingX + pattern.offsetX + rowVariation;
                                y = j * spacingY + pattern.offsetY + colVariation;
                                instRotation += pattern.rotation;
                                scaleMod = pattern.scale;
                                break;
                            default:
                                x = i * spacingX;
                                y = j * spacingY;
                        }
                        
                        // Aplicar offset de pantalla
                        x += offsetXVal;
                        
                        // Dibujar imagen
                        ctx.save();
                        ctx.translate(x + baseWidth / 2, y + baseHeight / 2);
                        ctx.rotate((instRotation * Math.PI) / 180);
                        ctx.scale(scaleMod, scaleMod);
                        ctx.drawImage(img, -baseWidth / 2, -baseHeight / 2, baseWidth, baseHeight);
                        ctx.restore();

                        counter++;
                    }
                }

                // Dibujar las 8 imágenes de perfume usando el mismo layout que en brush-reveal.js
        if (perfumeLoaded) {
                    try {
            // allow control over spacing/size via general config
            const spacingFactorH = parseFloat(config.perfumeSpacingH || 1.0);
            const spacingFactorV = parseFloat(config.perfumeSpacingV || 1.0);
            const sizeFactor = parseFloat(config.perfumeSizeFactor || 1.0);

            const baseMaxSize = Math.min(width, height) * 0.17;
            const maxSize = baseMaxSize * sizeFactor;
            const sPerf = Math.min(maxSize / perfumeImg.width, maxSize / perfumeImg.height);
            const pdw = Math.ceil(perfumeImg.width * sPerf);
            const pdh = Math.ceil(perfumeImg.height * sPerf);

            const centerX = width / 2;
            const centerY = height / 2;
            const spacingH = Math.min(width, height) * 0.25 * spacingFactorH;
            const spacingV = Math.min(width, height) * 0.2 * spacingFactorV;

                        const positions = [
                            { x: centerX - spacingH * 1.2, y: centerY - spacingV * 2 },
                            { x: centerX + spacingH * 1.2, y: centerY - spacingV * 2 },
                            { x: centerX, y: centerY - spacingV },
                            { x: centerX - spacingH * 1.4, y: centerY },
                            { x: centerX + spacingH * 1.4, y: centerY },
                            { x: centerX, y: centerY + spacingV },
                            { x: centerX - spacingH * 1.2, y: centerY + spacingV * 2 },
                            { x: centerX + spacingH * 1.2, y: centerY + spacingV * 2 }
                        ];

                        for (let p = 0; p < positions.length; p++) {
                            const pos = positions[p];
                            const dx = pos.x - pdw / 2;
                            const dy = pos.y - pdh / 2;
                            ctx.save();
                            // mantener transformaciones globales (zoom/rotate) aplicadas anteriormente
                            ctx.drawImage(perfumeImg, dx, dy, pdw, pdh);
                            ctx.restore();
                        }
                    } catch (e) {
                        console.warn('Error dibujando perfume positions', e);
                    }
                }
            }
            
            ctx.restore();
        }

        // Actualizar display de configuración
        function updateConfigDisplay() {
            const config = wallpaperState.general;
            const screenConfig = wallpaperState.screen;
            
            elements.currentOffset.textContent = `${screenConfig.offsetX || 0}px`;
            
            // Actualizar título del documento
            document.title = `Screen ${screenId} - ${config.patternType || 'organic-complex'} - ${wallpaperState.wallpaper?.isActive ? 'ON' : 'OFF'}`;
        }

        // Conectar al servidor
        socket.on('connect', () => {
            elements.connectionStatus.textContent = '✅ Conectado';
            elements.connectionStatus.style.background = '#28a745';
            socket.emit('registerScreen', { screenId: screenId, type: 'screen' });
        });

        socket.on('disconnect', () => {
            elements.connectionStatus.textContent = '❌ Desconectado';
            elements.connectionStatus.style.background = '#dc3545';
        });

        socket.on('initialState', (state) => {
            wallpaperState = { ...wallpaperState, ...state };
            updateConfigDisplay();
            generateStaticPattern();
        });

        socket.on('wallpaperToggle', (data) => {
            wallpaperState.wallpaper = data;
            updateConfigDisplay();
            generateStaticPattern();
        });

        socket.on('generalConfigUpdate', (config) => {
            wallpaperState.general = { ...wallpaperState.general, ...config };
            updateConfigDisplay();
            generateStaticPattern();
        });

        socket.on('screenConfigUpdate', (data) => {
            if (data.screenId === screenId) {
                wallpaperState.screen = { ...wallpaperState.screen, ...data.config };
                updateConfigDisplay();
                generateStaticPattern();
            }
        });

        // Redimensionar canvas cuando cambie el tamaño de ventana
        window.addEventListener('resize', () => {
            setupCanvas();
            generateStaticPattern();
        });

        // Toggle info con tecla 'i'
        document.addEventListener('keydown', (e) => {
            if (e.key === 'i' || e.key === 'I') {
                elements.screenInfo.style.display = 
                    elements.screenInfo.style.display === 'none' ? 'block' : 'none';
                elements.connectionStatus.style.display = 
                    elements.connectionStatus.style.display === 'none' ? 'block' : 'none';
            }
        });

        // Cargar imagen y inicializar
        img.onload = () => {
            imgLoaded = true;
            setupCanvas();
            updateConfigDisplay();
            generateStaticPattern();
        };

        img.onerror = () => {
            console.error('Error loading image');
            elements.connectionStatus.textContent = '❌ Error cargando imagen';
            elements.connectionStatus.style.background = '#dc3545';
        };

    // Cargar imagen sin perfume para el patrón
    img.src = '/sinperfume.png';

    // Cargar imagen perfume (se dibuja además del patrón)
    perfumeImg.onload = () => { perfumeLoaded = true; /* redraw if already initialized */ if (imgLoaded) generateStaticPattern(); };
    perfumeImg.onerror = () => { console.warn('Error loading perfume image'); };
    perfumeImg.src = '/perfume.png';

        // Inicialización
        setupCanvas();
    </script>
</body>
</html>
