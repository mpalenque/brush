<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wallpaper Screen - 3 Pantallas</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #f0f0f0;
            overflow: hidden;
        }

        .wallpaper-container {
            width: 6480px; /* 3 pantallas de 2160px cada una */
            height: 3840px;
            position: relative;
            overflow: hidden;
        }

        .pattern-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .screen-info {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
            font-family: monospace;
            display: none;
        }

        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #17a2b8;
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
            display: none;
        }
    </style>
</head>
<body>
    <div class="wallpaper-container" id="wallpaperContainer">
        <canvas class="pattern-canvas" id="patternCanvas"></canvas>
        
        <div class="screen-info" id="screenInfo">
            <div><strong>Canvas de 3 Pantallas:</strong> 6480x3840px</div>
            <div><em>Presiona 'i' para ocultar/mostrar esta información</em></div>
            <div><em>Presiona 'a' para guardar wallpaper</em></div>
        </div>
    </div>

    <div class="connection-status" id="connectionStatus">
        🔌 Conectando...
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const patternCanvas = document.getElementById('patternCanvas');
        const ctx = patternCanvas.getContext('2d');

        // Elementos de UI
        const elements = {
            screenInfo: document.getElementById('screenInfo'),
            connectionStatus: document.getElementById('connectionStatus')
        };

        // Estado del wallpaper con controles para 3 pantallas
        let wallpaperState = {
            general: {
                patternType: 'organic-complex',
                repetitionX: 200,
                repetitionY: 8,
                patternSize: 300,
                separationX: 300,
                separationY: 300,
                spacingX: 0,
                spacingY: 0,
                rotation: 0,
                zoom: 2.3,
                blendMode: 'multiply',
                backgroundColor: '#F5DDC7',
                selectedImage: 'red',
                patternSource: 'processed',
                // Controles para imágenes superpuestas (blue.png, red.png, pink.png)
                overlayImages: {
                    countX: 3,              // Cantidad en eje X
                    countY: 2,              // Cantidad en eje Y  
                    offsetX: 0,             // Offset horizontal
                    offsetY: 0,             // Offset vertical
                    size: 200,              // Tamaño de las imágenes
                    spacingX: 800,          // Espaciado entre imágenes en X
                    spacingY: 600,          // Espaciado entre imágenes en Y
                    rowOffsetX: 0,          // Desfase de filas en X
                    rowOffsetY: 0,          // Desfase de filas en Y
                    colOffsetX: 0,          // Desfase de columnas en X
                    colOffsetY: 0,          // Desfase de columnas en Y
                    alternateRowX: 0,       // Desfase filas intercaladas en X
                    alternateRowY: 0,       // Desfase filas intercaladas en Y
                    alternateColX: 0,       // Desfase columnas intercaladas en X
                    alternateColY: 0        // Desfase columnas intercaladas en Y
                }
            },
            wallpaper: { isActive: true }
        };

        let img = new Image();
        let imgLoaded = false;
        let overlayImg = new Image(); // Imagen superpuesta (blue, red, pink)
        let overlayLoaded = false;
        let selectedImage = 'red';

        // Configuración de canvas para 3 pantallas horizontales de 2160x3840
        function setupCanvas() {
            const totalWidth = 2160 * 3; // 6480px total
            const totalHeight = 3840;
            
            patternCanvas.width = totalWidth;
            patternCanvas.height = totalHeight;
            patternCanvas.style.width = totalWidth + 'px';
            patternCanvas.style.height = totalHeight + 'px';
        }

        function resolvePatternSrc() {
            const src = (wallpaperState.general?.patternSource) || 'processed';
            if (src === 'processed') return '/processed/processed.png';
            if (src === 'rojo') return '/patterns/rojo.png';
            if (src === 'azul') return '/patterns/azul.png';
            if (src === 'amarillo') return '/patterns/amarillo.png';
            return '/processed/processed.png';
        }

        // Generar patrón para canvas de 3 pantallas (6480x3840)
        function generateStaticPattern() {
            if (!imgLoaded) return;
            
            const config = wallpaperState.general;
            
            const repX = parseInt(config.repetitionX || 200);
            const repY = parseInt(config.repetitionY || 8);
            const size = parseInt(config.patternSize || 245);
            const separationX = parseInt(config.separationX || 300);
            const separationY = parseInt(config.separationY || 300);
            const spacingXExtra = parseInt(config.spacingX || 0);
            const spacingYExtra = parseInt(config.spacingY || 0);
            
            // Dimensiones del canvas de 3 pantallas
            const totalWidth = 2160 * 3; // 6480px
            const totalHeight = 3840;
            
            const rotationVal = parseInt(config.rotation || 0);

            // SPACING: Separación configurable + espaciado adicional
            const spacingX = separationX + spacingXExtra;
            const spacingY = separationY + spacingYExtra;
            
            const imgAspect = img.width / img.height;
            let baseWidth = size;
            let baseHeight = size;
            if (imgAspect > 1) baseHeight = baseWidth / imgAspect;
            else baseWidth = baseHeight * imgAspect;

            // Limpiar canvas
            ctx.save();
            ctx.clearRect(0, 0, totalWidth, totalHeight);
            
            // Color de fondo
            ctx.fillStyle = config.backgroundColor || '#ffffff';
            ctx.fillRect(0, 0, totalWidth, totalHeight);

            // Solo dibujar si el wallpaper está activo
            if (wallpaperState.wallpaper?.isActive) {
                // Efectos globales
                ctx.globalCompositeOperation = config.blendMode || 'multiply';

                // Transformaciones globales
                ctx.translate(totalWidth / 2, totalHeight / 2);
                const zoomVal = parseFloat(config.zoom || 1.2);
                ctx.scale(zoomVal, zoomVal);
                if (config.patternType === 'diamond') {
                    ctx.rotate(Math.PI / 4);
                }
                ctx.translate(-totalWidth / 2, -totalHeight / 2);

                let counter = 0;

                // Generar patrón que se repite a través de las 3 pantallas
                for (let j = 0; j < repY; j++) {
                    for (let i = 0; i < repX; i++) {
                        let x, y, instRotation = rotationVal, scaleMod = 1;

                        // Calcular posición según el tipo de patrón
                        switch (config.patternType) {
                            case 'grid':
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'brick':
                                x = i * spacingX + (j % 2 === 1 ? spacingX * 0.5 : 0);
                                y = j * spacingY;
                                break;
                            case 'hexagon':
                                x = i * spacingX + (j % 2 === 1 ? spacingX * 0.5 : 0);
                                y = j * spacingY * 0.866;
                                break;
                            case 'diamond':
                                x = i * spacingX + (j % 2 === 1 ? spacingX * 0.5 : 0);
                                y = j * spacingY * 0.8;
                                break;
                            case 'mirror-horizontal':
                                if (i % 2 !== 0) instRotation += 180;
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'mirror-vertical':
                                if (j % 2 !== 0) instRotation += 180;
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'mirror-both':
                                if (i % 2 !== 0) instRotation += 180;
                                if (j % 2 !== 0) instRotation += 180;
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'rotate-90':
                                instRotation += (counter % 4) * 90;
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'rotate-180':
                                if (counter % 2 !== 0) instRotation += 180;
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'rotate-mixed':
                                instRotation += [0, 90, 270, 180][counter % 4];
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'scale-varied':
                                scaleMod = [1, 0.6, 1.4, 0.8][counter % 4];
                                if (j % 2 !== 0) instRotation += 180;
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'alternating-scale':
                                const scaleDiff = parseFloat(config.scaleDifference || 1.5);
                                scaleMod = (counter % 2 === 0) ? 1 : scaleDiff;
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'organic-complex':
                                const patterns = [
                                    { offsetX: 0, offsetY: 0, rotation: 0, scale: 1 },
                                    { offsetX: spacingX * 0.3, offsetY: spacingY * 0.2, rotation: 180, scale: 0.8 },
                                    { offsetX: -spacingX * 0.1, offsetY: spacingY * 0.4, rotation: 90, scale: 1.2 },
                                    { offsetX: spacingX * 0.2, offsetY: -spacingY * 0.1, rotation: 270, scale: 0.9 },
                                    { offsetX: -spacingX * 0.2, offsetY: -spacingY * 0.3, rotation: 45, scale: 1.1 },
                                    { offsetX: spacingX * 0.4, offsetY: spacingY * 0.1, rotation: 135, scale: 0.7 },
                                    { offsetX: spacingX * 0.6, offsetY: spacingY * 0.3, rotation: 225, scale: 0.9 },
                                    { offsetX: -spacingX * 0.4, offsetY: spacingY * 0.5, rotation: 315, scale: 1.0 },
                                    { offsetX: spacingX * 0.8, offsetY: -spacingY * 0.2, rotation: 60, scale: 0.85 },
                                    { offsetX: -spacingX * 0.6, offsetY: -spacingY * 0.4, rotation: 120, scale: 1.15 },
                                    { offsetX: spacingX * 1.0, offsetY: spacingY * 0.6, rotation: 200, scale: 0.75 },
                                    { offsetX: -spacingX * 0.8, offsetY: spacingY * 0.1, rotation: 280, scale: 1.05 }
                                ];
                                
                                const patternIndex = (i + j * 2) % patterns.length;
                                const rowVariationIndex = j % 5;
                                const colVariationIndex = i % 3;
                                const lateralSpreadIndex = (i + j) % 7;
                                
                                const pattern = patterns[patternIndex];
                                
                                const rowVariation = rowVariationIndex * spacingX * 0.25;
                                const colVariation = colVariationIndex * spacingY * 0.15;
                                const lateralSpread = lateralSpreadIndex * spacingX * 0.1;
                                
                                x = i * spacingX + pattern.offsetX + rowVariation + lateralSpread;
                                y = j * spacingY + pattern.offsetY + colVariation;
                                instRotation += pattern.rotation;
                                scaleMod = pattern.scale;
                                break;
                            default:
                                x = i * spacingX;
                                y = j * spacingY;
                        }
                        
                        // Dibujar imagen del patrón
                        ctx.save();
                        ctx.translate(x + baseWidth / 2, y + baseHeight / 2);
                        ctx.rotate((instRotation * Math.PI) / 180);
                        ctx.scale(scaleMod, scaleMod);
                        ctx.drawImage(img, -baseWidth / 2, -baseHeight / 2, baseWidth, baseHeight);
                        ctx.restore();

                        counter++;
                    }
                }

                // Dibujar imágenes superpuestas usando configuración del control panel
                if (overlayLoaded) {
                    console.log('✅ Dibujando overlays con configuración del control panel...');
                    
                    // Obtener configuración de overlay del estado (con valores por defecto)
                    const overlayConfig = wallpaperState.general.overlayImages || {};
                    const gridX = overlayConfig.countX || 9;
                    const gridY = overlayConfig.countY || 4;
                    const overlaySize = overlayConfig.size || 200;
                    const spacingX = overlayConfig.spacingX || 800;
                    const spacingY = overlayConfig.spacingY || 600;
                    const offsetX = overlayConfig.offsetX || 0;
                    const offsetY = overlayConfig.offsetY || 0;
                    const rowOffsetX = overlayConfig.rowOffsetX || 0;
                    const rowOffsetY = overlayConfig.rowOffsetY || 0;
                    const colOffsetX = overlayConfig.colOffsetX || 0;
                    const colOffsetY = overlayConfig.colOffsetY || 0;
                    const alternateRowX = overlayConfig.alternateRowX || 0;
                    const alternateRowY = overlayConfig.alternateRowY || 0;
                    const alternateColX = overlayConfig.alternateColX || 0;
                    const alternateColY = overlayConfig.alternateColY || 0;
                    
                    const canvasWidth = 6480;
                    const canvasHeight = 3840;
                    
                    // Usar blend mode multiply para efecto superpuesto
                    ctx.globalCompositeOperation = 'multiply';
                    
                    // Patrones de desplazamiento irregulares pero consistentes
                    const irregularPatternX = [0, 0.15, -0.1, 0.25, -0.2, 0.1, -0.15, 0.2, -0.05];
                    const irregularPatternY = [0, -0.12, 0.18, -0.08];
                    
                    let overlaysDrawn = 0;
                    for (let row = 0; row < gridY; row++) {
                        for (let col = 0; col < gridX; col++) {
                            // Calcular desfases intercalados (filas/columnas pares vs impares)
                            const isEvenRow = (row % 2 === 0);
                            const isEvenCol = (col % 2 === 0);
                            const alternateRowOffsetX = isEvenRow ? 0 : alternateRowX;
                            const alternateRowOffsetY = isEvenRow ? 0 : alternateRowY;
                            const alternateColOffsetX = isEvenCol ? 0 : alternateColX;
                            const alternateColOffsetY = isEvenCol ? 0 : alternateColY;
                            
                            // Calcular posición base usando espaciado configurado
                            const baseX = (col * spacingX) + offsetX + (row * rowOffsetX) + (col * colOffsetX) + alternateRowOffsetX + alternateColOffsetX;
                            const baseY = (row * spacingY) + offsetY + (row * rowOffsetY) + (col * colOffsetY) + alternateRowOffsetY + alternateColOffsetY;
                            
                            // Usar patrones predefinidos para irregularidad consistente en posición
                            const offsetFactorX = irregularPatternX[col % irregularPatternX.length];
                            const offsetFactorY = irregularPatternY[row % irregularPatternY.length];
                            
                            const finalX = baseX + (offsetFactorX * spacingX * 0.1);
                            const finalY = baseY + (offsetFactorY * spacingY * 0.1);
                            
                            // Usar tamaño configurado desde el control panel
                            const finalWidth = overlaySize;
                            const finalHeight = overlaySize;
                            
                            // Dibujar imagen superpuesta
                            ctx.save();
                            ctx.drawImage(overlayImg, finalX, finalY, finalWidth, finalHeight);
                            ctx.restore();
                            overlaysDrawn++;
                        }
                    }
                    
                    // Restaurar blend mode normal
                    ctx.globalCompositeOperation = 'source-over';
                    console.log(`🎨 Overlays dibujados en grilla irregular: ${overlaysDrawn} (${gridX}x${gridY})`);
                }
            }
            
            ctx.restore();
        }

        // Conectar al servidor
        socket.on('connect', () => {
            elements.connectionStatus.textContent = '✅ Conectado';
            elements.connectionStatus.style.background = '#28a745';
            socket.emit('registerScreen', { screenId: 'main', type: 'screen' });
        });

        socket.on('disconnect', () => {
            elements.connectionStatus.textContent = '❌ Desconectado';
            elements.connectionStatus.style.background = '#dc3545';
        });

        socket.on('initialState', (state) => {
            wallpaperState = { ...wallpaperState, ...state };
            if (state && state.general && state.general.selectedImage) {
                selectedImage = state.general.selectedImage;
                overlayLoaded = false;
                overlayImg.src = `/${selectedImage}.png?t=${Date.now()}`;
            }
            // cargar base según fuente
            imgLoaded = false;
            img.src = `${resolvePatternSrc()}?t=${Date.now()}`;
        });

        socket.on('wallpaperToggle', (data) => {
            wallpaperState.wallpaper = data;
            generateStaticPattern();
        });

        socket.on('generalConfigUpdate', (config) => {
            wallpaperState.general = { ...wallpaperState.general, ...config };
            // Si cambia la fuente del patrón, recargar imagen base
            imgLoaded = false;
            img.src = `${resolvePatternSrc()}?t=${Date.now()}`;
            // Regenerar patrón inmediatamente si ambas imágenes están cargadas
            if (imgLoaded && overlayLoaded) {
                generateStaticPattern();
            }
        });

        // Actualización de selección de imagen desde el control (1/2/3)
        socket.on('imageSelected', (data) => {
            if (data && data.image) {
                selectedImage = data.image;
                // Recargar imagen superpuesta con la seleccionada
                overlayLoaded = false;
                overlayImg.src = `/${selectedImage}.png?t=${Date.now()}`;
            }
        });

        // Cuando el servidor avisa que hay nueva imagen procesada
        socket.on('imageUpdated', () => {
            // Sólo recargar cuando la fuente actual es 'processed'
            if ((wallpaperState.general?.patternSource) === 'processed') {
                imgLoaded = false;
                img.src = `/processed/processed.png?t=${Date.now()}`;
            }
        });

        // NUEVO: Capturar y enviar canvas completo cuando se solicite (para tecla 'a')
        socket.on('requestCanvasCapture', () => {
            try {
                console.log('📸 Capturando canvas completo para guardar como wallpaper.jpg...');
                
                // Asegurar que el patrón esté completamente renderizado
                if (!imgLoaded) {
                    console.warn('⚠️ Imagen no cargada, no se puede capturar canvas');
                    return;
                }
                
                // Capturar canvas como imagen base64
                const imageData = patternCanvas.toDataURL('image/png', 1.0);
                
                // Enviar al servidor
                socket.emit('saveScreenCanvas', {
                    imageData: imageData,
                    screenId: 'main',
                    timestamp: Date.now()
                });
                
                console.log('✅ Canvas enviado al servidor para guardar como wallpaper.jpg');
                
            } catch (error) {
                console.error('❌ Error capturando canvas:', error);
            }
        });

        // Confirmar que el canvas se guardó correctamente
        socket.on('canvasSaved', (data) => {
            if (data.success) {
                console.log(`✅ Canvas guardado exitosamente: ${data.filename}`);
            } else {
                console.error(`❌ Error guardando canvas: ${data.error}`);
            }
        });

        // Redimensionar canvas cuando cambie el tamaño de ventana
        window.addEventListener('resize', () => {
            setupCanvas();
            generateStaticPattern();
        });

        // Toggle info con tecla 'i' (ELIMINADO GUARDAR CON 'a' - ahora se hace desde control)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'i' || e.key === 'I') {
                elements.screenInfo.style.display = 
                    elements.screenInfo.style.display === 'none' ? 'block' : 'none';
                elements.connectionStatus.style.display = 
                    elements.connectionStatus.style.display === 'none' ? 'block' : 'none';
            }
        });

        // Cargar imagen base y inicializar
        img.onload = () => {
            imgLoaded = true;
            setupCanvas();
            generateStaticPattern();
        };

        img.onerror = () => {
            console.error('Error loading pattern image');
            elements.connectionStatus.textContent = '❌ Error cargando imagen de patrón';
            elements.connectionStatus.style.background = '#dc3545';
        };

        // Cargar imagen superpuesta (blue, red, pink)
        overlayImg.onload = () => { 
            overlayLoaded = true; 
            console.log(`✅ Overlay image loaded: ${overlayImg.src}`);
            console.log(`📐 Overlay dimensions: ${overlayImg.width}x${overlayImg.height}`);
            if (imgLoaded) generateStaticPattern(); 
        };
        
        overlayImg.onerror = () => { 
            console.error(`❌ Error loading overlay image: ${overlayImg.src}`); 
        };

        // Cargar imagen base para el patrón según fuente seleccionada
        img.src = resolvePatternSrc();
        
        // Cargar imagen superpuesta inicial
        overlayImg.src = `/${selectedImage}.png`;

        // Inicialización
        setupCanvas();
    </script>
</body>
</html>
