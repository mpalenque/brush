<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wallpaper Screen - Multi-Display</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #f0f0f0;
            min-height: 100vh;
        }

        .wallpaper-container {
            width: 100%;
            min-height: 100vh;
            position: relative;
            overflow: hidden;
        }

        .pattern-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .screen-info {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
            font-family: monospace;
            display: none;
        }

        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #17a2b8;
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
            display: none;
        }
    </style>
</head>
<body>
    <div class="wallpaper-container" id="wallpaperContainer">
        <canvas class="pattern-canvas" id="patternCanvas"></canvas>
        
        <div class="screen-info" id="screenInfo">
            <div><strong>Screen ID:</strong> <span id="screenId">0</span></div>
            <div><strong>Offset X:</strong> <span id="currentOffset">0px</span></div>
            <div><em>Presiona 'i' para ocultar/mostrar esta información</em></div>
        </div>
    </div>

    <div class="connection-status" id="connectionStatus">
        🔌 Conectando...
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const patternCanvas = document.getElementById('patternCanvas');
        const ctx = patternCanvas.getContext('2d');

        // Obtener Screen ID de la URL
        const pathParts = window.location.pathname.split('/');
        const screenId = parseInt(pathParts[pathParts.length - 1]);

        // Elementos de UI - CON OFFSET
        const elements = {
            screenInfo: document.getElementById('screenInfo'),
            screenId: document.getElementById('screenId'),
            currentOffset: document.getElementById('currentOffset'),
            connectionStatus: document.getElementById('connectionStatus')
        };

        // Estado del wallpaper - CON SOPORTE PARA OFFSET MANUAL Y SEPARACIÓN X
        let wallpaperState = {
            general: {
                patternType: 'organic-complex',
                repetitionX: 200,        // 200 repeticiones en X
                repetitionY: 8,
                patternSize: 300,
                separationX: 300,        // Solo separación horizontal configurable
                rotation: 0,
                zoom: 2.3,
                blendMode: 'multiply',
                backgroundColor: '#F5DDC7',
                selectedImage: 'red'
            },
            screen: {
                offsetX: 0 // Offset manual para esta pantalla
            },
            wallpaper: { isActive: true }
        };

    let img = new Image();
    let imgLoaded = false;
    // Perfume image (extra decorative layer) - load independently
    let perfumeImg = new Image();
    let perfumeLoaded = false;
    let selectedImage = 'red';

        // Mostrar Screen ID
        elements.screenId.textContent = screenId;

        // Configuración de canvas
        function setupCanvas() {
            const dpr = window.devicePixelRatio || 1;
            patternCanvas.width = window.innerWidth * dpr;
            patternCanvas.height = window.innerHeight * dpr;
            patternCanvas.style.width = '100%';
            patternCanvas.style.height = '100%';
        }

        // Generar patrón estático (sin animación)
        function generateStaticPattern() {
            if (!imgLoaded) return;
            
            const config = wallpaperState.general;
            const screenConfig = wallpaperState.screen;
            
            const repX = parseInt(config.repetitionX || 200);
            const repY = parseInt(config.repetitionY || 8);
            const size = parseInt(config.patternSize || 245);
            const separationX = parseInt(config.separationX || 300); // Solo separación X configurable
            const dpr = window.devicePixelRatio || 1;
            const width = window.innerWidth * dpr;
            const height = window.innerHeight * dpr;
            
            // Offset manual de esta pantalla
            const offsetXVal = (screenConfig.offsetX || 0) * dpr;
            const rotationVal = parseInt(config.rotation || 0);

            // CÁLCULO DE OFFSET GLOBAL PARA GRILLA 3x3
            // Posición de esta pantalla en la grilla (0-8 -> fila,columna)
            const screenRow = Math.floor(screenId / 3);  // 0, 1, 2
            const screenCol = screenId % 3;              // 0, 1, 2
            
            // Dimensiones de pantalla con gap
            const screenWidth = 2160;
            const screenHeight = 3840;
            const gapSize = 84;
            
            // Offset global basado en posición en la grilla
            const globalOffsetX = screenCol * (screenWidth + gapSize);
            const globalOffsetY = screenRow * (screenHeight + gapSize);

            // SPACING: Separación X configurable, Y como antes
            const spacingX = separationX * dpr;  // Separación X configurable
            const spacingY = height / repY;      // Separación Y como antes (basada en altura)
            
            const imgAspect = img.width / img.height;
            let baseWidth = size * dpr;
            let baseHeight = size * dpr;
            if (imgAspect > 1) baseHeight = baseWidth / imgAspect;
            else baseWidth = baseHeight * imgAspect;

            // Limpiar canvas
            ctx.save();
            ctx.clearRect(0, 0, width, height);
            
            // Color de fondo
            ctx.fillStyle = config.backgroundColor || '#ffffff';
            ctx.fillRect(0, 0, width, height);

            // Solo dibujar si el wallpaper está activo
            if (wallpaperState.wallpaper?.isActive) {
                // Efectos globales
                ctx.globalCompositeOperation = config.blendMode || 'multiply';

                // Transformaciones globales
                ctx.translate(width / 2, height / 2);
                const zoomVal = parseFloat(config.zoom || 1.2);
                ctx.scale(zoomVal, zoomVal);
                if (config.patternType === 'diamond') {
                    ctx.rotate(Math.PI / 4);
                }
                ctx.translate(-width / 2, -height / 2);

                let counter = 0;

                // SISTEMA ORIGINAL SIMPLE: Solo los elementos necesarios para la pantalla actual
                for (let j = 0; j < repY; j++) {
                    for (let i = 0; i < repX; i++) {
                        let x, y, instRotation = rotationVal, scaleMod = 1;

                        // Calcular posición según el tipo de patrón
                        switch (config.patternType) {
                            case 'grid':
                                x = i * spacingX - globalOffsetX + offsetXVal;
                                y = j * spacingY - globalOffsetY;
                                break;
                            case 'brick':
                                x = i * spacingX + (j % 2 === 1 ? spacingX * 0.5 : 0) - globalOffsetX + offsetXVal;
                                y = j * spacingY - globalOffsetY;
                                break;
                            case 'hexagon':
                                x = i * spacingX + (j % 2 === 1 ? spacingX * 0.5 : 0) - globalOffsetX + offsetXVal;
                                y = j * spacingY * 0.866 - globalOffsetY;
                                break;
                            case 'diamond':
                                x = i * spacingX + (j % 2 === 1 ? spacingX * 0.5 : 0) - globalOffsetX + offsetXVal;
                                y = j * spacingY * 0.8 - globalOffsetY;
                                break;
                            case 'mirror-horizontal':
                                if (i % 2 !== 0) instRotation += 180;
                                x = i * spacingX - globalOffsetX + offsetXVal;
                                y = j * spacingY - globalOffsetY;
                                break;
                            case 'mirror-vertical':
                                if (j % 2 !== 0) instRotation += 180;
                                x = i * spacingX - globalOffsetX + offsetXVal;
                                y = j * spacingY - globalOffsetY;
                                break;
                            case 'mirror-both':
                                if (i % 2 !== 0) instRotation += 180;
                                if (j % 2 !== 0) instRotation += 180;
                                x = i * spacingX - globalOffsetX + offsetXVal;
                                y = j * spacingY - globalOffsetY;
                                break;
                            case 'rotate-90':
                                instRotation += (counter % 4) * 90;
                                x = i * spacingX - globalOffsetX + offsetXVal;
                                y = j * spacingY - globalOffsetY;
                                break;
                            case 'rotate-180':
                                if (counter % 2 !== 0) instRotation += 180;
                                x = i * spacingX - globalOffsetX + offsetXVal;
                                y = j * spacingY - globalOffsetY;
                                break;
                            case 'rotate-mixed':
                                instRotation += [0, 90, 270, 180][counter % 4];
                                x = i * spacingX - globalOffsetX + offsetXVal;
                                y = j * spacingY - globalOffsetY;
                                break;
                            case 'scale-varied':
                                scaleMod = [1, 0.6, 1.4, 0.8][counter % 4];
                                if (j % 2 !== 0) instRotation += 180;
                                x = i * spacingX - globalOffsetX + offsetXVal;
                                y = j * spacingY - globalOffsetY;
                                break;
                            case 'alternating-scale':
                                const scaleDiff = parseFloat(config.scaleDifference || 1.5);
                                scaleMod = (counter % 2 === 0) ? 1 : scaleDiff;
                                x = i * spacingX - globalOffsetX + offsetXVal;
                                y = j * spacingY - globalOffsetY;
                                break;
                            case 'organic-complex':
                                // PATRÓN ORGÁNICO DETERMINÍSTICO: Mismo seed para todas las pantallas
                                // Para que todas las pantallas generen exactamente el mismo patrón,
                                // usamos un seed fijo basado en las coordenadas de la grilla (i,j)
                                
                                const patterns = [
                                    { offsetX: 0, offsetY: 0, rotation: 0, scale: 1 },
                                    { offsetX: spacingX * 0.3, offsetY: spacingY * 0.2, rotation: 180, scale: 0.8 },
                                    { offsetX: -spacingX * 0.1, offsetY: spacingY * 0.4, rotation: 90, scale: 1.2 },
                                    { offsetX: spacingX * 0.2, offsetY: -spacingY * 0.1, rotation: 270, scale: 0.9 },
                                    { offsetX: -spacingX * 0.2, offsetY: -spacingY * 0.3, rotation: 45, scale: 1.1 },
                                    { offsetX: spacingX * 0.4, offsetY: spacingY * 0.1, rotation: 135, scale: 0.7 },
                                    { offsetX: spacingX * 0.6, offsetY: spacingY * 0.3, rotation: 225, scale: 0.9 },
                                    { offsetX: -spacingX * 0.4, offsetY: spacingY * 0.5, rotation: 315, scale: 1.0 },
                                    { offsetX: spacingX * 0.8, offsetY: -spacingY * 0.2, rotation: 60, scale: 0.85 },
                                    { offsetX: -spacingX * 0.6, offsetY: -spacingY * 0.4, rotation: 120, scale: 1.15 },
                                    { offsetX: spacingX * 1.0, offsetY: spacingY * 0.6, rotation: 200, scale: 0.75 },
                                    { offsetX: -spacingX * 0.8, offsetY: spacingY * 0.1, rotation: 280, scale: 1.05 }
                                ];
                                
                                // Usar coordenadas de grilla (i,j) para generar el mismo patrón en todas las pantallas
                                const patternIndex = (i + j * 2) % patterns.length;
                                const rowVariationIndex = j % 5;
                                const colVariationIndex = i % 3;
                                const lateralSpreadIndex = (i + j) % 7;
                                
                                const pattern = patterns[patternIndex];
                                
                                // Variaciones determinísticas basadas en coordenadas de grilla
                                const rowVariation = rowVariationIndex * spacingX * 0.25;
                                const colVariation = colVariationIndex * spacingY * 0.15;
                                const lateralSpread = lateralSpreadIndex * spacingX * 0.1;
                                
                                x = i * spacingX + pattern.offsetX + rowVariation + lateralSpread - globalOffsetX + offsetXVal;
                                y = j * spacingY + pattern.offsetY + colVariation - globalOffsetY;
                                instRotation += pattern.rotation;
                                scaleMod = pattern.scale;
                                break;
                            default:
                                x = i * spacingX - globalOffsetX + offsetXVal;
                                y = j * spacingY - globalOffsetY;
                        }
                        
                        // Dibujar imagen
                        ctx.save();
                        ctx.translate(x + baseWidth / 2, y + baseHeight / 2);
                        ctx.rotate((instRotation * Math.PI) / 180);
                        ctx.scale(scaleMod, scaleMod);
                        ctx.drawImage(img, -baseWidth / 2, -baseHeight / 2, baseWidth, baseHeight);
                        ctx.restore();

                        counter++;
                    }
                }

                // Dibujar las 8 imágenes de perfume usando el mismo layout que en brush-reveal.js
        if (perfumeLoaded) {
                    try {
            // allow control over spacing/size via general config
            const spacingFactorH = parseFloat(config.perfumeSpacingH || 1.0);
            const spacingFactorV = parseFloat(config.perfumeSpacingV || 1.0);
            const sizeFactor = parseFloat(config.perfumeSizeFactor || 1.0);

            const baseMaxSize = Math.min(width, height) * 0.17;
            const maxSize = baseMaxSize * sizeFactor;
            const sPerf = Math.min(maxSize / perfumeImg.width, maxSize / perfumeImg.height);
            const pdw = Math.ceil(perfumeImg.width * sPerf);
            const pdh = Math.ceil(perfumeImg.height * sPerf);

            const centerX = width / 2;
            const centerY = height / 2;
            const spacingH = Math.min(width, height) * 0.25 * spacingFactorH;
            const spacingV = Math.min(width, height) * 0.2 * spacingFactorV;

                        const positions = [
                            { x: centerX - spacingH * 1.2, y: centerY - spacingV * 2 },
                            { x: centerX + spacingH * 1.2, y: centerY - spacingV * 2 },
                            { x: centerX, y: centerY - spacingV },
                            { x: centerX - spacingH * 1.4, y: centerY },
                            { x: centerX + spacingH * 1.4, y: centerY },
                            { x: centerX, y: centerY + spacingV },
                            { x: centerX - spacingH * 1.2, y: centerY + spacingV * 2 },
                            { x: centerX + spacingH * 1.2, y: centerY + spacingV * 2 }
                        ];

                        for (let p = 0; p < positions.length; p++) {
                            const pos = positions[p];
                            const dx = pos.x - pdw / 2;
                            const dy = pos.y - pdh / 2;
                            ctx.save();
                            // mantener transformaciones globales (zoom/rotate) aplicadas anteriormente
                            ctx.drawImage(perfumeImg, dx, dy, pdw, pdh);
                            ctx.restore();
                        }
                    } catch (e) {
                        console.warn('Error dibujando perfume positions', e);
                    }
                }
            }
            
            ctx.restore();
        }

        // Actualizar display de configuración
        function updateConfigDisplay() {
            const config = wallpaperState.general;
            const screenConfig = wallpaperState.screen;
            
            elements.currentOffset.textContent = `${screenConfig.offsetX || 0}px`;
            
            // Actualizar título del documento
            document.title = `Screen ${screenId} - ${config.patternType || 'organic-complex'} - ${wallpaperState.wallpaper?.isActive ? 'ON' : 'OFF'}`;
        }

        // Conectar al servidor
        socket.on('connect', () => {
            elements.connectionStatus.textContent = '✅ Conectado';
            elements.connectionStatus.style.background = '#28a745';
            socket.emit('registerScreen', { screenId: screenId, type: 'screen' });
        });

        socket.on('disconnect', () => {
            elements.connectionStatus.textContent = '❌ Desconectado';
            elements.connectionStatus.style.background = '#dc3545';
        });

        socket.on('initialState', (state) => {
            wallpaperState = { ...wallpaperState, ...state };
            if (state && state.general && state.general.selectedImage) {
                selectedImage = state.general.selectedImage;
                // Forzar recarga de la imagen de perfume según selección inicial
                perfumeLoaded = false;
                perfumeImg.src = `/${selectedImage}.png?t=${Date.now()}`;
            }
            updateConfigDisplay();
            generateStaticPattern();
        });

        socket.on('wallpaperToggle', (data) => {
            wallpaperState.wallpaper = data;
            updateConfigDisplay();
            generateStaticPattern();
        });

        socket.on('generalConfigUpdate', (config) => {
            wallpaperState.general = { ...wallpaperState.general, ...config };
            updateConfigDisplay();
            generateStaticPattern();
        });

        // Actualización de selección de imagen desde el control (1/2/3)
        socket.on('imageSelected', (data) => {
            if (data && data.image) {
                selectedImage = data.image;
                // Recargar imagen de perfume con la seleccionada
                perfumeLoaded = false;
                perfumeImg.src = `/${selectedImage}.png?t=${Date.now()}`;
            }
        });

        socket.on('screenConfigUpdate', (data) => {
            if (data.screenId === screenId) {
                wallpaperState.screen = { ...wallpaperState.screen, ...data.config };
                updateConfigDisplay();
                generateStaticPattern();
            }
        });

        // Cuando el servidor avisa que hay nueva imagen procesada
        socket.on('imageUpdated', () => {
            // Recargar patrón con cache-busting y regenerar
            imgLoaded = false;
            img.src = `/processed/processed.png?t=${Date.now()}`;
        });

        // NUEVO: Capturar y enviar canvas completo cuando se solicite
        socket.on('requestCanvasCapture', () => {
            try {
                console.log('📸 Capturando canvas completo para guardar...');
                
                // Asegurar que el patrón esté completamente renderizado
                if (!imgLoaded) {
                    console.warn('⚠️ Imagen no cargada, no se puede capturar canvas');
                    return;
                }
                
                // Capturar canvas como imagen base64
                const imageData = patternCanvas.toDataURL('image/png', 1.0);
                
                // Enviar al servidor
                socket.emit('saveScreenCanvas', {
                    imageData: imageData,
                    screenId: screenId,
                    timestamp: Date.now()
                });
                
                console.log('✅ Canvas enviado al servidor para guardar');
                
            } catch (error) {
                console.error('❌ Error capturando canvas:', error);
            }
        });

        // Confirmar que el canvas se guardó correctamente
        socket.on('canvasSaved', (data) => {
            if (data.success) {
                console.log(`✅ Canvas guardado exitosamente: ${data.filename}`);
            } else {
                console.error(`❌ Error guardando canvas: ${data.error}`);
            }
        });

        // Redimensionar canvas cuando cambie el tamaño de ventana
        window.addEventListener('resize', () => {
            setupCanvas();
            generateStaticPattern();
        });

        // Toggle info con tecla 'i'
        document.addEventListener('keydown', (e) => {
            if (e.key === 'i' || e.key === 'I') {
                elements.screenInfo.style.display = 
                    elements.screenInfo.style.display === 'none' ? 'block' : 'none';
                elements.connectionStatus.style.display = 
                    elements.connectionStatus.style.display === 'none' ? 'block' : 'none';
            }
        });

        // Cargar imagen y inicializar
        img.onload = () => {
            imgLoaded = true;
            setupCanvas();
            updateConfigDisplay();
            generateStaticPattern();
        };

        img.onerror = () => {
            console.error('Error loading image');
            elements.connectionStatus.textContent = '❌ Error cargando imagen';
            elements.connectionStatus.style.background = '#dc3545';
        };

    // Cargar imagen procesada para el patrón
    img.src = '/processed/processed.png';

    // Cargar imagen perfume (se dibuja además del patrón) según imagen seleccionada
    perfumeImg.onload = () => { perfumeLoaded = true; if (imgLoaded) generateStaticPattern(); };
    perfumeImg.onerror = () => { console.warn('Error loading perfume image'); };
    // Inicial por estado general si está disponible, si no 'red'
    perfumeImg.src = `/${selectedImage}.png`;

        // Inicialización
        setupCanvas();
    </script>
</body>
</html>
