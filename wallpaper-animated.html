<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wallpaper Generator - Animated</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #f0f0f0;
            min-height: 100vh;
        }

        /* Contenedor principal del wallpaper */
        .wallpaper-container {
            width: 100%;
            min-height: 100vh;
            position: relative;
            overflow: hidden;
        }

        /* Contenedor para patrones avanzados */
        .pattern-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        /* Panel de control */
        .control-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            z-index: 100;
            min-width: 280px;
            backdrop-filter: blur(10px);
        }

        .control-panel h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: bold;
            font-size: 14px;
        }

        .control-group input, .control-group select, .control-panel button {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        
        .control-panel button {
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
        }
        
        .control-panel button:hover {
            background-color: #0056b3;
        }

        .control-group input[type="range"] {
            margin: 5px 0;
        }

        .control-group input[type="color"] {
            height: 40px;
            cursor: pointer;
        }

        /* Botón para alternar el panel */
        .toggle-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            z-index: 101;
            font-size: 14px;
        }

        .toggle-panel:hover {
            background: #0056b3;
        }
    </style>
</head>
<body>
    <button class="toggle-panel" id="togglePanel">⚙️ Controles</button>
    
    <div class="wallpaper-container" id="wallpaperContainer">
        <canvas class="pattern-canvas" id="patternCanvas"></canvas>
    </div>

    <div class="control-panel" id="controlPanel">
        <h3>🎨 Control de Wallpaper Animado</h3>
        
        <div class="control-group">
            <button id="animateBtn" style="background-color: #28a745;">▶️ Iniciar Animación</button>
        </div>

        <div class="control-group">
            <label for="patternType">Tipo de Patrón:</label>
            <select id="patternType">
                <option value="grid">Cuadrícula Simple</option>
                <option value="brick" selected>Ladrillo (Offset)</option>
                <option value="metro-tile">Azulejo de Metro</option>
                <option value="diamond">Diamante Rotado</option>
                <option value="stepped">Patrón Escalonado</option>
                <option value="checkerboard">Damero (Tablero)</option>
                <option value="mirror-h">Espejo Horizontal</option>
                <option value="mirror-v">Espejo Vertical</option>
                <option value="mirror-both">Espejo Cuádruple</option>
                <option value="rotate-90">Rotación 90°</option>
                <option value="rotate-180">Rotación 180°</option>
                <option value="rotate-mixed">Rotación Mixta</option>
                <option value="scale-varied">Escalado Variado</option>
                <option value="alternating-scale">Escala Alternada</option>
                <option value="hexagon">Hexagonal</option>
            </select>
        </div>

        <div class="control-group" id="scaleDifferenceContainer" style="display: none;">
            <label for="scaleDifference">Diferencia de Escala:</label>
            <input type="range" id="scaleDifference" min="1.1" max="5" value="1.5" step="0.1">
            <span id="scaleDifferenceValue">1.5x</span>
        </div>

        <div class="control-group">
            <label for="repetitionX">Repeticiones Horizontales:</label>
            <input type="range" id="repetitionX" min="1" max="30" value="10" step="1">
            <span id="repetitionXValue">10</span>
        </div>

        <div class="control-group">
            <label for="repetitionY">Repeticiones Verticales:</label>
            <input type="range" id="repetitionY" min="1" max="30" value="8" step="1">
            <span id="repetitionYValue">8</span>
        </div>

        <div class="control-group">
            <label for="patternSize">Tamaño del Patrón:</label>
            <input type="range" id="patternSize" min="20" max="300" value="245" step="5">
            <span id="sizeValue">245px</span>
        </div>
        
        <div class="control-group">
            <label for="opacity">Opacidad del Patrón:</label>
            <input type="range" id="opacity" min="0" max="100" value="100" step="5">
            <span id="opacityValue">100%</span>
        </div>

        <div class="control-group">
            <label for="rotation">Rotación Individual:</label>
            <input type="range" id="rotation" min="0" max="360" value="0" step="15">
            <span id="rotationValue">0°</span>
        </div>

        <div class="control-group">
            <label for="zoom">Zoom General:</label>
            <input type="range" id="zoom" min="0.1" max="3.0" value="1.2" step="0.1">
            <span id="zoomValue">120%</span>
        </div>

        <div class="control-group">
            <label for="blendMode">Modo de Mezcla:</label>
            <select id="blendMode">
                <option value="normal">Normal</option>
                <option value="multiply" selected>Multiplicar</option>
                <option value="screen">Pantalla</option>
                <option value="overlay">Superponer</option>
                <option value="soft-light">Luz Suave</option>
                <option value="hard-light">Luz Fuerte</option>
                <option value="color-dodge">Subexponer Color</option>
                <option value="color-burn">Sobreexponer Color</option>
                <option value="difference">Diferencia</option>
                <option value="exclusion">Exclusión</option>
                <option value="lighten">Aclarar</option>
                <option value="darken">Oscurecer</option>
                <option value="saturation">Saturación</option>
                <option value="color">Color</option>
                <option value="luminosity">Luminosidad</option>
                <option value="hue">Matiz</option>
                <option value="plus-lighter">Aditivo</option>
            </select>
        </div>

        <div class="control-group">
            <label for="backgroundColor">Color de Fondo:</label>
            <input type="color" id="backgroundColor" value="#ffffff">
        </div>

        <div class="control-group">
            <label for="animationSpeed">Velocidad de Animación:</label>
            <input type="range" id="animationSpeed" min="100" max="3000" value="800" step="50">
            <span id="animationSpeedValue">800ms</span>
        </div>
        
        <div class="control-group">
             <button id="downloadBtn" style="margin-top: 10px;">📥 Descargar Wallpaper</button>
        </div>
    </div>

    <script>
        const wallpaperContainer = document.getElementById('wallpaperContainer');
        const patternCanvas = document.getElementById('patternCanvas');
        const controlPanel = document.getElementById('controlPanel');
        const togglePanel = document.getElementById('togglePanel');
        const animateBtn = document.getElementById('animateBtn');
        const ctx = patternCanvas.getContext('2d');

        // --- State Variables ---
        let isAnimating = false;
        let animationFrameId = null;
        let imageInstances = [];
        let img = new Image();
        let imgLoaded = false;

        // --- UI Elements ---
        const controls = {
            patternType: document.getElementById('patternType'),
            repetitionX: document.getElementById('repetitionX'),
            repetitionY: document.getElementById('repetitionY'),
            patternSize: document.getElementById('patternSize'),
            animationSpeed: document.getElementById('animationSpeed'),
            backgroundColor: document.getElementById('backgroundColor'),
            opacity: document.getElementById('opacity'),
            rotation: document.getElementById('rotation'),
            zoom: document.getElementById('zoom'),
            blendMode: document.getElementById('blendMode'),
            scaleDifference: document.getElementById('scaleDifference'),
        };

        const values = {
            repetitionXValue: document.getElementById('repetitionXValue'),
            repetitionYValue: document.getElementById('repetitionYValue'),
            sizeValue: document.getElementById('sizeValue'),
            animationSpeedValue: document.getElementById('animationSpeedValue'),
            opacityValue: document.getElementById('opacityValue'),
            rotationValue: document.getElementById('rotationValue'),
            zoomValue: document.getElementById('zoomValue'),
            scaleDifferenceValue: document.getElementById('scaleDifferenceValue'),
        };
        
        const scaleDifferenceContainer = document.getElementById('scaleDifferenceContainer');
        const downloadBtn = document.getElementById('downloadBtn');

        // --- Core Functions ---

        function setupCanvas() {
            const dpr = window.devicePixelRatio || 1;
            patternCanvas.width = window.innerWidth * dpr;
            patternCanvas.height = window.innerHeight * dpr;
            patternCanvas.style.width = '100%';
            patternCanvas.style.height = '100%';
            // The dpr scaling is now applied directly in the draw function to account for zoom
        }

        function updateUI() {
            values.repetitionXValue.textContent = controls.repetitionX.value;
            values.repetitionYValue.textContent = controls.repetitionY.value;
            values.sizeValue.textContent = controls.patternSize.value + 'px';
            values.animationSpeedValue.textContent = controls.animationSpeed.value + 'ms';
            values.opacityValue.textContent = controls.opacity.value + '%';
            values.rotationValue.textContent = controls.rotation.value + '°';
            values.zoomValue.textContent = Math.round(controls.zoom.value * 100) + '%';
            if (controls.patternType.value === 'alternating-scale') {
                values.scaleDifferenceValue.textContent = controls.scaleDifference.value + 'x';
            }
            wallpaperContainer.style.backgroundColor = controls.backgroundColor.value;
        }

        function prepareImageInstances() {
            imageInstances = [];
            const { 
                patternType, repetitionX, repetitionY, patternSize, 
                rotation 
            } = controls;
            
            const repX = parseInt(repetitionX.value);
            const repY = parseInt(repetitionY.value);
            const size = parseInt(patternSize.value);
            const dpr = window.devicePixelRatio || 1;
            const width = window.innerWidth * dpr;
            const height = window.innerHeight * dpr;
            const offsetXVal = -10 * dpr; // Hardcoded value
            const offsetYVal = 0 * dpr; // Hardcoded value
            const rotationVal = parseInt(rotation.value);
            const scaleDiff = parseFloat(controls.scaleDifference.value);

            const spacingX = width / repX;
            const spacingY = height / repY;
            
            const imgAspect = img.width / img.height;
            let baseWidth = size * dpr;
            let baseHeight = size * dpr;
            if (imgAspect > 1) baseHeight = baseWidth / imgAspect;
            else baseWidth = baseHeight * imgAspect;

            let counter = 0;

            for (let j = 0; j < repY; j++) {
                for (let i = 0; i < repX; i++) {
                    let x, y, instRotation = rotationVal, scaleMod = 1;
                    const rowOffset = (j % 2) * (spacingX / 2);

                    // Pattern specific logic
                    switch (patternType.value) {
                        case 'brick':
                            x = i * spacingX + rowOffset;
                            y = j * spacingY;
                            break;
                        case 'metro-tile':
                             x = i * spacingX + (j % 3) * (spacingX / 3);
                             y = j * spacingY;
                             break;
                        case 'stepped':
                            x = i * spacingX + (j * spacingX * 0.3);
                            y = j * spacingY;
                            break;
                        case 'hexagon':
                            x = i * spacingX + rowOffset;
                            y = j * spacingY * 0.866;
                            break;
                        case 'mirror-h':
                            if (i % 2 !== 0) instRotation += 180;
                            x = i * spacingX;
                            y = j * spacingY;
                            break;
                        case 'mirror-v':
                            if (j % 2 !== 0) instRotation += 180;
                            x = i * spacingX;
                            y = j * spacingY;
                            break;
                        case 'mirror-both':
                            if (i % 2 !== 0) instRotation += 180;
                            if (j % 2 !== 0) instRotation += 180;
                            x = i * spacingX;
                            y = j * spacingY;
                            break;
                        case 'rotate-90':
                            instRotation += (counter % 4) * 90;
                            x = i * spacingX;
                            y = j * spacingY;
                            break;
                         case 'rotate-180':
                            if (counter % 2 !== 0) instRotation += 180;
                            x = i * spacingX;
                            y = j * spacingY;
                            break;
                        case 'rotate-mixed':
                            instRotation += [0, 90, 270, 180][counter % 4];
                             x = i * spacingX;
                            y = j * spacingY;
                            break;
                        case 'scale-varied':
                            scaleMod = [1, 0.6, 1.4, 0.8][counter % 4];
                            x = i * spacingX;
                            y = j * spacingY;
                            break;
                        case 'alternating-scale':
                            scaleMod = (counter % 2 === 0) ? 1 : scaleDiff;
                            x = i * spacingX;
                            y = j * spacingY;
                            break;
                        default: // grid, diamond, etc.
                            x = i * spacingX;
                            y = j * spacingY;
                    }
                    
                    imageInstances.push({
                        x: x + offsetXVal,
                        y: y + offsetYVal,
                        drawWidth: baseWidth * scaleMod,
                        drawHeight: baseHeight * scaleMod,
                        rotation: instRotation,
                        finalScale: 1,
                        currentScale: 0,
                        startTime: 0,
                    });
                    counter++;
                }
            }
            
            // Sort for organic, root-like growth from bottom-center
            const startX = width / 2;
            const startY = height * 1.1; // Start slightly below the screen for a better effect

            imageInstances.sort((a, b) => {
                const distA = Math.hypot(a.x - startX, a.y - startY);
                const distB = Math.hypot(b.x - startX, b.y - startY);
                // Add a small random factor to break up perfect circles
                return (distA + Math.random() * (width/10)) - (distB + Math.random() * (width/10));
            });
        }

        function draw() {
            const dpr = window.devicePixelRatio || 1;
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            ctx.save();
            ctx.clearRect(0, 0, width * dpr, height * dpr);
            
            // 1. Draw background color
            ctx.fillStyle = controls.backgroundColor.value;
            ctx.fillRect(0, 0, width * dpr, height * dpr);

            // 2. Set global effects
            ctx.globalAlpha = parseFloat(controls.opacity.value) / 100;
            ctx.globalCompositeOperation = controls.blendMode.value;

            // 3. Apply global zoom and transformations
            ctx.translate((width * dpr) / 2, (height * dpr) / 2);
            const zoomVal = parseFloat(controls.zoom.value);
            ctx.scale(zoomVal, zoomVal);
            if (controls.patternType.value === 'diamond') {
                 ctx.rotate(45 * Math.PI / 180);
            }
            ctx.translate(-(width * dpr) / 2, -(height * dpr) / 2);


            // 4. Draw all image instances
            imageInstances.forEach(inst => {
                if (inst.currentScale > 0.01) {
                    ctx.save();
                    ctx.translate(inst.x + inst.drawWidth / 2, inst.y + inst.drawHeight / 2);
                    ctx.rotate(inst.rotation * Math.PI / 180);
                    ctx.scale(inst.currentScale, inst.currentScale);
                    ctx.drawImage(img, -inst.drawWidth / 2, -inst.drawHeight / 2, inst.drawWidth, inst.drawHeight);
                    ctx.restore();
                }
            });
            
            ctx.restore();
        }

        function animate(time) {
            if (!isAnimating) return;

            const animSpeed = parseInt(controls.animationSpeed.value);
            const staggerDelay = 50; 

            let allAnimationsDone = true;

            imageInstances.forEach((inst, index) => {
                if (inst.startTime === 0) {
                    inst.startTime = time;
                }

                const timeSinceStart = time - inst.startTime;
                const delay = index * staggerDelay;

                if (timeSinceStart > delay) {
                    const elapsed = timeSinceStart - delay;
                    const progress = Math.min(elapsed / animSpeed, 1);
                    inst.currentScale = easeOutCubic(progress);
                } else {
                    inst.currentScale = 0;
                }
                
                if (inst.currentScale < inst.finalScale) {
                    allAnimationsDone = false;
                }
            });

            draw();
            
            if (allAnimationsDone) {
                isAnimating = false;
                animateBtn.disabled = false;
                animateBtn.textContent = "▶️ Iniciar Animación";
                animateBtn.style.backgroundColor = '#28a745';
            } else {
                animationFrameId = requestAnimationFrame(animate);
            }
        }
        
        function easeOutCubic(t) {
            return (--t) * t * t + 1;
        }

        function startAnimation() {
            if (isAnimating) return;
            isAnimating = true;
            animateBtn.disabled = true;
            animateBtn.textContent = "Animating...";
            animateBtn.style.backgroundColor = '#007bff';

            prepareImageInstances();
            imageInstances.forEach(inst => {
                inst.startTime = 0;
                inst.currentScale = 0;
            });
            animationFrameId = requestAnimationFrame(animate);
        }
        
        function handleControlChange() {
            updateUI();
            if (isAnimating) {
                // Stop current animation if controls change
                cancelAnimationFrame(animationFrameId);
                isAnimating = false;
                animateBtn.disabled = false;
                animateBtn.textContent = "▶️ Iniciar Animación";
                animateBtn.style.backgroundColor = '#28a745';
            }
            // Draw a static preview of the final state
            prepareImageInstances();
            imageInstances.forEach(inst => inst.currentScale = inst.finalScale);
            draw();
        }
        
        function downloadWallpaper() {
            const canvas = patternCanvas;
            const link = document.createElement('a');
            link.download = `wallpaper-animated-${controls.patternType.value}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // --- Event Listeners ---
        togglePanel.addEventListener('click', () => {
            controlPanel.style.display = controlPanel.style.display === 'none' ? 'block' : 'none';
        });

        animateBtn.addEventListener('click', startAnimation);
        downloadBtn.addEventListener('click', downloadWallpaper);

        window.addEventListener('resize', () => {
            setupCanvas();
            handleControlChange();
        });

        Object.values(controls).forEach(control => {
            control.addEventListener('input', handleControlChange);
        });
        
        controls.patternType.addEventListener('change', () => {
            scaleDifferenceContainer.style.display = controls.patternType.value === 'alternating-scale' ? 'block' : 'none';
            handleControlChange();
        });

        // --- Initialization ---
        img.onload = () => {
            imgLoaded = true;
            setupCanvas();
            updateUI();
            // Draw initial static state
            handleControlChange();
        };
        img.onerror = () => {
            console.error("No se pudo cargar pattern2.png");
            alert("Error: No se pudo cargar la imagen 'pattern2.png'. Asegúrate de que esté en la misma carpeta.");
        };
        img.src = 'pattern2.png';

    </script>
</body>
</html>
