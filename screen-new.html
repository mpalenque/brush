<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wallpaper Screen - 3 Pantallas</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #f0f0f0;
            overflow: hidden;
        }

        .wallpaper-container {
            width: 6480px; /* 3 pantallas de 2160px cada una */
            height: 3840px;
            position: relative;
            overflow: hidden;
        }

        .pattern-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .screen-info {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
            font-family: monospace;
            display: none;
        }

        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #17a2b8;
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
            display: none;
        }
    </style>
</head>
<body>
    <div class="wallpaper-container" id="wallpaperContainer">
        <canvas class="pattern-canvas" id="patternCanvas"></canvas>
        
        <div class="screen-info" id="screenInfo">
            <div><strong>Canvas de 3 Pantallas:</strong> 6480x3840px</div>
            <div><em>Presiona 'i' para ocultar/mostrar esta información</em></div>
            <div><em>Presiona 'a' para guardar wallpaper</em></div>
        </div>
    </div>

    <div class="connection-status" id="connectionStatus">
        🔌 Conectando...
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const patternCanvas = document.getElementById('patternCanvas');
        const ctx = patternCanvas.getContext('2d');

        // Elementos de UI
        const elements = {
            screenInfo: document.getElementById('screenInfo'),
            connectionStatus: document.getElementById('connectionStatus')
        };

        // Estado del wallpaper con controles para 3 pantallas
        let wallpaperState = {
            general: {
                patternType: 'organic-complex',
                repetitionX: 200,
                repetitionY: 8,
                patternSize: 300,
                separationX: 300,
                separationY: 300,
                spacingX: 0,
                spacingY: 0,
                rotation: 0,
                zoom: 2.3,
                blendMode: 'multiply',
                backgroundColor: '#F5DDC7',
                selectedImage: 'red',
                patternSource: 'processed',
                // Controles para imágenes superpuestas (blue.png, red.png, pink.png)
                overlayImages: {
                    countX: 3,              // Cantidad en eje X
                    countY: 2,              // Cantidad en eje Y  
                    offsetX: 0,             // Offset horizontal
                    offsetY: 0,             // Offset vertical
                    size: 200,              // Tamaño de las imágenes
                    spacingX: 800,          // Espaciado entre imágenes en X
                    spacingY: 600           // Espaciado entre imágenes en Y
                }
            },
            wallpaper: { isActive: true }
        };

        let img = new Image();
        let imgLoaded = false;
        let overlayImg = new Image(); // Imagen superpuesta (blue, red, pink)
        let overlayLoaded = false;
        let selectedImage = 'red';

        // Configuración de canvas para 3 pantallas horizontales de 2160x3840
        function setupCanvas() {
            const totalWidth = 2160 * 3; // 6480px total
            const totalHeight = 3840;
            
            patternCanvas.width = totalWidth;
            patternCanvas.height = totalHeight;
            patternCanvas.style.width = totalWidth + 'px';
            patternCanvas.style.height = totalHeight + 'px';
        }

        function resolvePatternSrc() {
            const src = (wallpaperState.general?.patternSource) || 'processed';
            if (src === 'processed') return '/processed/processed.png';
            if (src === 'rojo') return '/patterns/rojo.png';
            if (src === 'azul') return '/patterns/azul.png';
            if (src === 'amarillo') return '/patterns/amarillo.png';
            return '/processed/processed.png';
        }

        // Generar patrón para canvas de 3 pantallas (6480x3840)
        function generateStaticPattern() {
            if (!imgLoaded) return;
            
            const config = wallpaperState.general;
            
            const repX = parseInt(config.repetitionX || 200);
            const repY = parseInt(config.repetitionY || 8);
            const size = parseInt(config.patternSize || 245);
            const separationX = parseInt(config.separationX || 300);
            const separationY = parseInt(config.separationY || 300);
            const spacingXExtra = parseInt(config.spacingX || 0);
            const spacingYExtra = parseInt(config.spacingY || 0);
            
            // Dimensiones del canvas de 3 pantallas
            const totalWidth = 2160 * 3; // 6480px
            const totalHeight = 3840;
            
            const rotationVal = parseInt(config.rotation || 0);

            // SPACING: Separación configurable + espaciado adicional
            const spacingX = separationX + spacingXExtra;
            const spacingY = separationY + spacingYExtra;
            
            const imgAspect = img.width / img.height;
            let baseWidth = size;
            let baseHeight = size;
            if (imgAspect > 1) baseHeight = baseWidth / imgAspect;
            else baseWidth = baseHeight * imgAspect;

            // Limpiar canvas
            ctx.save();
            ctx.clearRect(0, 0, totalWidth, totalHeight);
            
            // Color de fondo
            ctx.fillStyle = config.backgroundColor || '#ffffff';
            ctx.fillRect(0, 0, totalWidth, totalHeight);

            // Solo dibujar si el wallpaper está activo
            if (wallpaperState.wallpaper?.isActive) {
                // Efectos globales
                ctx.globalCompositeOperation = config.blendMode || 'multiply';

                // Transformaciones globales
                ctx.translate(totalWidth / 2, totalHeight / 2);
                const zoomVal = parseFloat(config.zoom || 1.2);
                ctx.scale(zoomVal, zoomVal);
                if (config.patternType === 'diamond') {
                    ctx.rotate(Math.PI / 4);
                }
                ctx.translate(-totalWidth / 2, -totalHeight / 2);

                let counter = 0;

                // Generar patrón que se repite a través de las 3 pantallas
                for (let j = 0; j < repY; j++) {
                    for (let i = 0; i < repX; i++) {
                        let x, y, instRotation = rotationVal, scaleMod = 1;

                        // Calcular posición según el tipo de patrón
                        switch (config.patternType) {
                            case 'grid':
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'brick':
                                x = i * spacingX + (j % 2 === 1 ? spacingX * 0.5 : 0);
                                y = j * spacingY;
                                break;
                            case 'hexagon':
                                x = i * spacingX + (j % 2 === 1 ? spacingX * 0.5 : 0);
                                y = j * spacingY * 0.866;
                                break;
                            case 'diamond':
                                x = i * spacingX + (j % 2 === 1 ? spacingX * 0.5 : 0);
                                y = j * spacingY * 0.8;
                                break;
                            case 'mirror-horizontal':
                                if (i % 2 !== 0) instRotation += 180;
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'mirror-vertical':
                                if (j % 2 !== 0) instRotation += 180;
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'mirror-both':
                                if (i % 2 !== 0) instRotation += 180;
                                if (j % 2 !== 0) instRotation += 180;
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'rotate-90':
                                instRotation += (counter % 4) * 90;
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'rotate-180':
                                if (counter % 2 !== 0) instRotation += 180;
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'rotate-mixed':
                                instRotation += [0, 90, 270, 180][counter % 4];
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'scale-varied':
                                scaleMod = [1, 0.6, 1.4, 0.8][counter % 4];
                                if (j % 2 !== 0) instRotation += 180;
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'alternating-scale':
                                const scaleDiff = parseFloat(config.scaleDifference || 1.5);
                                scaleMod = (counter % 2 === 0) ? 1 : scaleDiff;
                                x = i * spacingX;
                                y = j * spacingY;
                                break;
                            case 'organic-complex':
                                const patterns = [
                                    { offsetX: 0, offsetY: 0, rotation: 0, scale: 1 },
                                    { offsetX: spacingX * 0.3, offsetY: spacingY * 0.2, rotation: 180, scale: 0.8 },
                                    { offsetX: -spacingX * 0.1, offsetY: spacingY * 0.4, rotation: 90, scale: 1.2 },
                                    { offsetX: spacingX * 0.2, offsetY: -spacingY * 0.1, rotation: 270, scale: 0.9 },
                                    { offsetX: -spacingX * 0.2, offsetY: -spacingY * 0.3, rotation: 45, scale: 1.1 },
                                    { offsetX: spacingX * 0.4, offsetY: spacingY * 0.1, rotation: 135, scale: 0.7 },
                                    { offsetX: spacingX * 0.6, offsetY: spacingY * 0.3, rotation: 225, scale: 0.9 },
                                    { offsetX: -spacingX * 0.4, offsetY: spacingY * 0.5, rotation: 315, scale: 1.0 },
                                    { offsetX: spacingX * 0.8, offsetY: -spacingY * 0.2, rotation: 60, scale: 0.85 },
                                    { offsetX: -spacingX * 0.6, offsetY: -spacingY * 0.4, rotation: 120, scale: 1.15 },
                                    { offsetX: spacingX * 1.0, offsetY: spacingY * 0.6, rotation: 200, scale: 0.75 },
                                    { offsetX: -spacingX * 0.8, offsetY: spacingY * 0.1, rotation: 280, scale: 1.05 }
                                ];
                                
                                const patternIndex = (i + j * 2) % patterns.length;
                                const rowVariationIndex = j % 5;
                                const colVariationIndex = i % 3;
                                const lateralSpreadIndex = (i + j) % 7;
                                
                                const pattern = patterns[patternIndex];
                                
                                const rowVariation = rowVariationIndex * spacingX * 0.25;
                                const colVariation = colVariationIndex * spacingY * 0.15;
                                const lateralSpread = lateralSpreadIndex * spacingX * 0.1;
                                
                                x = i * spacingX + pattern.offsetX + rowVariation + lateralSpread;
                                y = j * spacingY + pattern.offsetY + colVariation;
                                instRotation += pattern.rotation;
                                scaleMod = pattern.scale;
                                break;
                            default:
                                x = i * spacingX;
                                y = j * spacingY;
                        }
                        
                        // Dibujar imagen del patrón
                        ctx.save();
                        ctx.translate(x + baseWidth / 2, y + baseHeight / 2);
                        ctx.rotate((instRotation * Math.PI) / 180);
                        ctx.scale(scaleMod, scaleMod);
                        ctx.drawImage(img, -baseWidth / 2, -baseHeight / 2, baseWidth, baseHeight);
                        ctx.restore();

                        counter++;
                    }
                }

                // Dibujar imágenes superpuestas (blue.png, red.png, pink.png)
                if (overlayLoaded && config.overlayImages) {
                    const overlayConfig = config.overlayImages;
                    const overlayCountX = parseInt(overlayConfig.countX || 3);
                    const overlayCountY = parseInt(overlayConfig.countY || 2);
                    const overlayOffsetX = parseInt(overlayConfig.offsetX || 0);
                    const overlayOffsetY = parseInt(overlayConfig.offsetY || 0);
                    const overlaySize = parseInt(overlayConfig.size || 200);
                    const overlaySpacingX = parseInt(overlayConfig.spacingX || 800);
                    const overlaySpacingY = parseInt(overlayConfig.spacingY || 600);

                    const overlayAspect = overlayImg.width / overlayImg.height;
                    let overlayWidth = overlaySize;
                    let overlayHeight = overlaySize;
                    if (overlayAspect > 1) overlayHeight = overlayWidth / overlayAspect;
                    else overlayWidth = overlayHeight * overlayAspect;

                    // Resetear globalCompositeOperation para que las imágenes se vean encima
                    ctx.globalCompositeOperation = 'source-over';

                    for (let oy = 0; oy < overlayCountY; oy++) {
                        for (let ox = 0; ox < overlayCountX; ox++) {
                            const overlayX = ox * overlaySpacingX + overlayOffsetX;
                            const overlayY = oy * overlaySpacingY + overlayOffsetY;

                            ctx.save();
                            ctx.drawImage(overlayImg, overlayX, overlayY, overlayWidth, overlayHeight);
                            ctx.restore();
                        }
                    }
                }
            }
            
            ctx.restore();
        }

        // Conectar al servidor
        socket.on('connect', () => {
            elements.connectionStatus.textContent = '✅ Conectado';
            elements.connectionStatus.style.background = '#28a745';
            socket.emit('registerScreen', { screenId: 'main', type: 'screen' });
        });

        socket.on('disconnect', () => {
            elements.connectionStatus.textContent = '❌ Desconectado';
            elements.connectionStatus.style.background = '#dc3545';
        });

        socket.on('initialState', (state) => {
            wallpaperState = { ...wallpaperState, ...state };
            if (state && state.general && state.general.selectedImage) {
                selectedImage = state.general.selectedImage;
                overlayLoaded = false;
                overlayImg.src = `/${selectedImage}.png?t=${Date.now()}`;
            }
            // cargar base según fuente
            imgLoaded = false;
            img.src = `${resolvePatternSrc()}?t=${Date.now()}`;
        });

        socket.on('wallpaperToggle', (data) => {
            wallpaperState.wallpaper = data;
            generateStaticPattern();
        });

        socket.on('generalConfigUpdate', (config) => {
            wallpaperState.general = { ...wallpaperState.general, ...config };
            // Si cambia la fuente del patrón, recargar imagen base
            imgLoaded = false;
            img.src = `${resolvePatternSrc()}?t=${Date.now()}`;
        });

        // Actualización de selección de imagen desde el control (1/2/3)
        socket.on('imageSelected', (data) => {
            if (data && data.image) {
                selectedImage = data.image;
                // Recargar imagen superpuesta con la seleccionada
                overlayLoaded = false;
                overlayImg.src = `/${selectedImage}.png?t=${Date.now()}`;
            }
        });

        // Cuando el servidor avisa que hay nueva imagen procesada
        socket.on('imageUpdated', () => {
            // Sólo recargar cuando la fuente actual es 'processed'
            if ((wallpaperState.general?.patternSource) === 'processed') {
                imgLoaded = false;
                img.src = `/processed/processed.png?t=${Date.now()}`;
            }
        });

        // Redimensionar canvas cuando cambie el tamaño de ventana
        window.addEventListener('resize', () => {
            setupCanvas();
            generateStaticPattern();
        });

        // Toggle info con tecla 'i' y guardar con tecla 'a'
        document.addEventListener('keydown', (e) => {
            if (e.key === 'i' || e.key === 'I') {
                elements.screenInfo.style.display = 
                    elements.screenInfo.style.display === 'none' ? 'block' : 'none';
                elements.connectionStatus.style.display = 
                    elements.connectionStatus.style.display === 'none' ? 'block' : 'none';
            }
            
            // Funcionalidad de guardar wallpaper con tecla 'a'
            if (e.key === 'a' || e.key === 'A') {
                saveWallpaper();
            }
        });

        // Función para guardar el wallpaper
        function saveWallpaper() {
            try {
                console.log('📸 Guardando wallpaper...');
                
                // Capturar canvas como imagen
                const imageData = patternCanvas.toDataURL('image/png', 1.0);
                
                // Crear enlace de descarga
                const link = document.createElement('a');
                link.download = `wallpaper_3screens_${Date.now()}.png`;
                link.href = imageData;
                link.click();
                
                console.log('✅ Wallpaper guardado');
                
                // También enviar al servidor si está conectado
                if (socket && socket.connected) {
                    socket.emit('saveWallpaper', {
                        imageData: imageData,
                        timestamp: Date.now()
                    });
                }
                
            } catch (error) {
                console.error('❌ Error guardando wallpaper:', error);
            }
        }

        // Cargar imagen base y inicializar
        img.onload = () => {
            imgLoaded = true;
            setupCanvas();
            generateStaticPattern();
        };

        img.onerror = () => {
            console.error('Error loading pattern image');
            elements.connectionStatus.textContent = '❌ Error cargando imagen de patrón';
            elements.connectionStatus.style.background = '#dc3545';
        };

        // Cargar imagen superpuesta (blue, red, pink)
        overlayImg.onload = () => { 
            overlayLoaded = true; 
            if (imgLoaded) generateStaticPattern(); 
        };
        
        overlayImg.onerror = () => { 
            console.warn('Error loading overlay image'); 
        };

        // Cargar imagen base para el patrón según fuente seleccionada
        img.src = resolvePatternSrc();
        
        // Cargar imagen superpuesta inicial
        overlayImg.src = `/${selectedImage}.png`;

        // Inicialización
        setupCanvas();
    </script>
</body>
</html>
